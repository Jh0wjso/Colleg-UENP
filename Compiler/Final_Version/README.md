# ğŸ“ƒ JLanguage

A Linguagem Jlanguage Ã© uma linguagem de programaÃ§Ã£o criada para fins didÃ¡ticos e Ã© voltada para o ensino de conceitos bÃ¡sicos de programaÃ§Ã£o. Ela possui uma sintaxe simples e fÃ¡cil de entender, com foco em operaÃ§Ãµes aritmÃ©ticas e comandos bÃ¡sicos de entrada e saÃ­da.

A Linguagem foi criada usando Xtext, que Ã©

## ğŸ› ï¸ Ferramentas usadas

* [Java](https://www.java.com/pt-BR/) - Liguagem de ProgramaÃ§Ã£o usada
* [xText](https://www.eclipse.org/Xtext/) - Framework para geraÃ§Ã£o de cÃ³digo
* [Eclipse](https://www.eclipse.org/downloads/) - IDE necessÃ¡ria para geraÃ§Ã£o do cÃ³digo

## ğŸ“‹ PrÃ©-requisitos

* JDK do java instalado e os demais componentes necessÃ¡rios para o java
* Eclipse IDE, instalada
* Xtext prÃ© configurado no seu Eclipse

## ğŸ’» Compiler

Pasta que armazena toda a estutura por trÃ¡s do compilador o qual foi criado usando xText.

O projeto possui cincon principais projetos, porÃ©mo que iremos alterar Ã© somente o inicial, localizado em br.compiladores.jhonatan.jlanguage, na pasta *src* temos o arquivo chamado Jlanguage.xtex, que Ã© onde se localiza a gramÃ¡tica da linguagem, a baixo segue a gramÃ¡tica ultlizada:

```
grammar br.compiladores.jhonatan.jlanguage.Jlanguage with org.eclipse.xtext.common.Terminals

generate jlanguage "http://www.compiladores.br/jhonatan/jlanguage/Jlanguage"

Programa:
    ':' 'VARIAVEIS' (declaracoes+=Declaracao)+
    ':' 'CODIGO' (comandos+=Comando)+;

Declaracao:
    name=ID ':' tipo=TipoVar;

ExpressaoAritmetica:
    termo1=TermoAritmetico outrosTermos+=OutroTermoAritmetico*;

OutroTermoAritmetico:
    operador=OpArit1 termo=TermoAritmetico;

TermoAritmetico:
    fator1=FatorAritmetico outrosFatores+=OutroFatorAritmetico*;

OutroFatorAritmetico:
    operador=OpArit2 fator=FatorAritmetico;

FatorAritmetico:
    FatorNumero | FatorVariavel | FatorSubExpressao;

FatorNumero:
    numero=INT;

FatorVariavel:
    variavel=[Declaracao];

FatorSubExpressao:
    '(' expressao=ExpressaoAritmetica ')';

ExpressaoRelacional:
    termo1=TermoRelacional outrosTermos+=OutroTermoRelacional*;

OutroTermoRelacional:
    operador=OpBool termo=TermoRelacional;

TermoRelacional:
    TermoComparacaoRelacional | TermoSubExpressaoRelacional;

TermoComparacaoRelacional:
    expr1=ExpressaoAritmetica opRel=OpRel expr2=ExpressaoAritmetica;

TermoSubExpressaoRelacional:
    '[' expRel=ExpressaoRelacional ']';

Comando:
    ComandoAtibuicao | ComandoEntrada | ComandoSaida | ComandoCondicao | ComandoRepeticao | ComandoSubAlgoritmo;

ComandoAtibuicao:
    'ATRIBUIR' exp=ExpressaoAritmetica 'A' variavel=[Declaracao];

ComandoEntrada:
    'LEIA' variavel=[Declaracao];

ComandoSaida:
    'PRINT' variavel=[Declaracao];

ComandoCondicao:
    'SE' exp=ExpressaoRelacional 'ENTAO' cmd1=Comando ('SENAO' cmd2=Comando)?;

ComandoRepeticao:
    'ENQUANTO' exp=ExpressaoRelacional cmd=Comando;

ComandoSubAlgoritmo:
    'INICIO' (comandos+=Comando)+ 'FIM';

ChamadaFuncao:
    name=ID '(' (argumentos+=ExpressaoAritmetica (',' argumentos+=ExpressaoAritmetica)*)? ')';

Funcao:
    'FUNCAO' name=ID '(' (parametros+=Declaracao (',' parametros+=Declaracao)*)? ')' ':' tipo=TipoVar comandos=Comando;

TipoVar:
    'INTEIRO' | 'REAL' | 'TEXTO' | 'BOOLEANO';

OpArit1:
    '+' | '-';

OpArit2:
    '*' | '/';

OpRel:
    '>' | '>=' | '<' | '<=' | '<>' | '=';

OpBool:
    'E' | 'OU';

```

ApÃ³s a gramÃ¡tica definida, na pasta generator detro da pasta src contÃ©m o  aquivo chamado de JlanguageGenerator.xtend, que basicamente Ã© o arquivo, que Ã© responsÃ¡vel por definiar a como o cÃ³digo serÃ¡ traduzido de .jlang para java, abaixo segue o cÃ³digo ultilizado:

```
/*
 * generated by Xtext 2.30.0-SNAPSHOT
 */
package br.compiladores.jhonatan.jlanguage.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.compiladores.jhonatan.jlanguage.jlanguage.Programa
import br.compiladores.jhonatan.jlanguage.jlanguage.Declaracao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoAtibuicao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoEntrada
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoSaida
import br.compiladores.jhonatan.jlanguage.jlanguage.Funcao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoCondicao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoRepeticao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoSubAlgoritmo
import br.compiladores.jhonatan.jlanguage.jlanguage.ExpressaoAritmetica
import org.eclipse.xtend2.lib.StringConcatenation
import br.compiladores.jhonatan.jlanguage.jlanguage.TermoAritmetico
import br.compiladores.jhonatan.jlanguage.jlanguage.FatorNumero
import br.compiladores.jhonatan.jlanguage.jlanguage.FatorVariavel
import br.compiladores.jhonatan.jlanguage.jlanguage.FatorSubExpressao
import br.compiladores.jhonatan.jlanguage.jlanguage.ExpressaoRelacional
import br.compiladores.jhonatan.jlanguage.jlanguage.TermoComparacaoRelacional
import br.compiladores.jhonatan.jlanguage.jlanguage.TermoSubExpressaoRelacional

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JlanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for(p: resource.allContents.toIterable.filter(Programa)){
			fsa.generateFile("Programa.java", p.compilePrograma)
		}
	}

	def compilePrograma(Programa p) '''
		public class Programa{
			Â«FOR d:p.declaracoesÂ»
			static Â«getTipo(d)Â» Â«d.nameÂ»;
			Â«ENDFORÂ»

			public static void main(String args[]){
				Â«FOR c : p.comandosÂ»
					Â«c.compileComandoÂ»
				Â«ENDFORÂ»
			}
		}
	'''

	def getTipo(Declaracao d){
		if(d.tipo == "REAL") return "double";
		if(d.tipo == "TEXTO") return "string";
		if(d.tipo == "BOOLEANO") return "boolean";
		return "int";
	}

	def dispatch compileComando(ComandoAtibuicao c)'''
		Â«c.variavel.nameÂ» = Â«c.exp.compileExpressaoÂ»;
	'''

	def dispatch compileComando(ComandoEntrada c)'''
		Â«IF c.variavel.tipo == "INTEIRO"Â»
			Â«c.variavel.nameÂ» = Integer.parseInt(System.console().readLine());
		Â«ELSEIF c.variavel.tipo == "REAL"Â»
			Â«c.variavel.nameÂ» = Double.parseDouble(System.console().readLine());
		Â«ELSEIF c.variavel.tipo == "TEXTO"Â»
			Â«c.variavel.nameÂ» = System.console().readLine();
		Â«ELSEIF c.variavel.tipo == "BOOLEANO"Â»
			Â«c.variavel.nameÂ» = Boolean.parseBoolean(System.console().readLine());
		Â«ENDIFÂ»
	'''

	def dispatch compileComando(ComandoSaida c)'''
		System.out.println(Â«c.variavel.nameÂ»);
	'''

	def dispatch compileComando(ComandoCondicao c)'''
		if(Â«c.exp.compileExpressaoRelacionalÂ») Â«c.cmd1.compileComandoÂ»
		Â«IF c.cmd2 !== nullÂ»else Â«c.cmd2.compileComandoÂ»Â«ENDIFÂ»
	'''

	def dispatch compileComando(ComandoRepeticao c)'''
		while(Â«c.exp.compileExpressaoRelacionalÂ») Â«c.cmd.compileComandoÂ»
	'''

	def dispatch compileComando(ComandoSubAlgoritmo cs)'''
		{
			Â«FOR c:cs.comandosÂ»
				Â«c.compileComandoÂ»
			Â«ENDFORÂ»
		}
	'''

	def compileExpressao(ExpressaoAritmetica e){
		val ret = new StringConcatenation

		ret.append(e.termo1.compileTermo)
		e.outrosTermos.forEach[ot | 
			ret.append(" "+ot.operador+" "+ot.termo.compileTermo)
		]

		return ret
	}

	def compileTermo(TermoAritmetico t){
		val ret = new StringConcatenation

		ret.append(t.fator1.compileFator)
		t.outrosFatores.forEach[of | 
			ret.append(" "+of.operador+" "+of.fator.compileFator)
		]

		return ret
	}

	def dispatch compileFator(FatorNumero fn)'''Â«fn.numeroÂ»'''
	def dispatch compileFator(FatorVariavel fv)'''Â«fv.variavel.nameÂ»'''
	def dispatch compileFator(FatorSubExpressao fse)'''Â«fse.expressao.compileExpressaoÂ»'''

	def compileExpressaoRelacional(ExpressaoRelacional e){
		val ret = new StringConcatenation

		ret.append(e.termo1.compileTermoRelacional)
		e.outrosTermos.forEach[ot | 
			ret.append(" "+ot.operador.compileOperadorBooleno+" "+ ot.termo.compileTermoRelacional)
		]

		return ret
	}


	def compileOperadorBooleno(String s){
		if(s == "E") return "&&"
		else return "||"
	}

	def dispatch compileTermoRelacional(TermoComparacaoRelacional tcr){
		return tcr.expr1.compileExpressao + " " + tcr.opRel.compileOperadorRelacional + " " + tcr.expr2.compileExpressao
	}

	def dispatch compileTermoRelacional(TermoSubExpressaoRelacional tser)'''(Â«tser.expRelÂ»)'''

	def compileOperadorRelacional(String s){
		if(s == "<") return "<"
		else if(s == "<=") return "<="
		else if(s == ">") return ">"
		else if(s == ">=") return ">="
		else if(s == "<>") return "!=" 
		else if(s == "=") return "=="
	}
}

```

ApÃ³s toda essa anÃ¡lise cliando com o botÃ£o direito no projeto chamado br.compiladores.jhonatan.jlanguage, e clique em Run as, Eclipse Aplication, porÃ©m a primeira vez em que o cÃ³digo for ser executado rode as configuraÃ§Ãµes do das EclipseAplication e configure para o JavaSE-11.

## ğŸ““ Code

ApÃ³s gerar a EclipseAplication, Ã© necessÃ¡rio criar um projeto Java e criar um arquivo programa.jlang e escreva seu cÃ³digo, se tudo ocorrer como o planejado a EclipseAplication Ã© capaz de reconhecer o extensÃ£o .jlang, a prÃ³pria eclipse aplication Ã© capaz de gerar a pasta scr-gen e o arquivo Programa.java, abaixo segue um exemplo que apresenta todos os comandos que a linguagem Ã© capaz de realizar:

```
:VARIAVEIS
argumento:INTEIRO
fatorial:INTEIRO

:CODIGO
LEIA argumento
ATRIBUIR argumento A fatorial
SE argumento = 0 ENTAO ATRIBUIR 1 A fatorial
ENQUANTO argumento > 1
   INICIO
      ATRIBUIR fatorial * (argumento - 1) A fatorial
      ATRIBUIR argumento - 1 A argumento
   FIM
PRINT fatorial
```

Para testar o seu cÃ³dgo java Ã© necessÃ¡rio atravÃ©z do terminal acessando a pasta e execute os seguintes comandos:

Caso o seu cÃ³digo apresente algum erro o seguinte comando jÃ¡ Ã© capaz de apresentar os erros no terminal:

```
javac Programa.java
```

Logo apÃ³s isso rode o seguinte comando:

```
java -cp . Programa
```

Pronto tudo ocorreu como o planejado seu cÃ³digo estÃ¡ funcionando! Fique a vontade para experimentar e codar!

## ğŸ“Œ Version

O programa estÃ¡ em sua primeira versÃ£o completa, a VersÃ£o 1.0.

## âœ’ï¸ Creator

* **Developer** - [Jhonatan SilvÃ©rio de Oliveira](https://github.com/Jh0wjso)

---



## ğŸ”” Notas

O projeto foi desenvolvido a partir do curso de compiladores da UFSCar, link do curso, [Clique Aqui](https://www.youtube.com/playlist?list=PLaPmgS59eMSEKNRIBxuBK4mJr-8pFP3lW).
