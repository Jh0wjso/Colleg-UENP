# 📃 JLanguage

A Linguagem Jlanguage é uma linguagem de programação criada para fins didáticos e é voltada para o ensino de conceitos básicos de programação. Ela possui uma sintaxe simples e fácil de entender, com foco em operações aritméticas e comandos básicos de entrada e saída.

A Linguagem foi criada usando Xtext, que é

## 🛠️ Ferramentas usadas

* [Java](https://www.java.com/pt-BR/) - Liguagem de Programação usada
* [xText](https://www.eclipse.org/Xtext/) - Framework para geração de código
* [Eclipse](https://www.eclipse.org/downloads/) - IDE necessária para geração do código

## 📋 Pré-requisitos

* JDK do java instalado e os demais componentes necessários para o java
* Eclipse IDE, instalada
* Xtext pré configurado no seu Eclipse

## 💻 Compiler

Pasta que armazena toda a estutura por trás do compilador o qual foi criado usando xText.

O projeto possui cincon principais projetos, porémo que iremos alterar é somente o inicial, localizado em br.compiladores.jhonatan.jlanguage, na pasta *src* temos o arquivo chamado Jlanguage.xtex, que é onde se localiza a gramática da linguagem, a baixo segue a gramática ultlizada:

```
grammar br.compiladores.jhonatan.jlanguage.Jlanguage with org.eclipse.xtext.common.Terminals

generate jlanguage "http://www.compiladores.br/jhonatan/jlanguage/Jlanguage"

Programa:
    ':' 'VARIAVEIS' (declaracoes+=Declaracao)+
    ':' 'CODIGO' (comandos+=Comando)+;

Declaracao:
    name=ID ':' tipo=TipoVar;

ExpressaoAritmetica:
    termo1=TermoAritmetico outrosTermos+=OutroTermoAritmetico*;

OutroTermoAritmetico:
    operador=OpArit1 termo=TermoAritmetico;

TermoAritmetico:
    fator1=FatorAritmetico outrosFatores+=OutroFatorAritmetico*;

OutroFatorAritmetico:
    operador=OpArit2 fator=FatorAritmetico;

FatorAritmetico:
    FatorNumero | FatorVariavel | FatorSubExpressao;

FatorNumero:
    numero=INT;

FatorVariavel:
    variavel=[Declaracao];

FatorSubExpressao:
    '(' expressao=ExpressaoAritmetica ')';

ExpressaoRelacional:
    termo1=TermoRelacional outrosTermos+=OutroTermoRelacional*;

OutroTermoRelacional:
    operador=OpBool termo=TermoRelacional;

TermoRelacional:
    TermoComparacaoRelacional | TermoSubExpressaoRelacional;

TermoComparacaoRelacional:
    expr1=ExpressaoAritmetica opRel=OpRel expr2=ExpressaoAritmetica;

TermoSubExpressaoRelacional:
    '[' expRel=ExpressaoRelacional ']';

Comando:
    ComandoAtibuicao | ComandoEntrada | ComandoSaida | ComandoCondicao | ComandoRepeticao | ComandoSubAlgoritmo;

ComandoAtibuicao:
    'ATRIBUIR' exp=ExpressaoAritmetica 'A' variavel=[Declaracao];

ComandoEntrada:
    'LEIA' variavel=[Declaracao];

ComandoSaida:
    'PRINT' variavel=[Declaracao];

ComandoCondicao:
    'SE' exp=ExpressaoRelacional 'ENTAO' cmd1=Comando ('SENAO' cmd2=Comando)?;

ComandoRepeticao:
    'ENQUANTO' exp=ExpressaoRelacional cmd=Comando;

ComandoSubAlgoritmo:
    'INICIO' (comandos+=Comando)+ 'FIM';

ChamadaFuncao:
    name=ID '(' (argumentos+=ExpressaoAritmetica (',' argumentos+=ExpressaoAritmetica)*)? ')';

Funcao:
    'FUNCAO' name=ID '(' (parametros+=Declaracao (',' parametros+=Declaracao)*)? ')' ':' tipo=TipoVar comandos=Comando;

TipoVar:
    'INTEIRO' | 'REAL' | 'TEXTO' | 'BOOLEANO';

OpArit1:
    '+' | '-';

OpArit2:
    '*' | '/';

OpRel:
    '>' | '>=' | '<' | '<=' | '<>' | '=';

OpBool:
    'E' | 'OU';

```

Após a gramática definida, na pasta generator detro da pasta src contém o  aquivo chamado de JlanguageGenerator.xtend, que basicamente é o arquivo, que é responsável por definiar a como o código será traduzido de .jlang para java, abaixo segue o código ultilizado:

```
/*
 * generated by Xtext 2.30.0-SNAPSHOT
 */
package br.compiladores.jhonatan.jlanguage.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.compiladores.jhonatan.jlanguage.jlanguage.Programa
import br.compiladores.jhonatan.jlanguage.jlanguage.Declaracao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoAtibuicao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoEntrada
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoSaida
import br.compiladores.jhonatan.jlanguage.jlanguage.Funcao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoCondicao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoRepeticao
import br.compiladores.jhonatan.jlanguage.jlanguage.ComandoSubAlgoritmo
import br.compiladores.jhonatan.jlanguage.jlanguage.ExpressaoAritmetica
import org.eclipse.xtend2.lib.StringConcatenation
import br.compiladores.jhonatan.jlanguage.jlanguage.TermoAritmetico
import br.compiladores.jhonatan.jlanguage.jlanguage.FatorNumero
import br.compiladores.jhonatan.jlanguage.jlanguage.FatorVariavel
import br.compiladores.jhonatan.jlanguage.jlanguage.FatorSubExpressao
import br.compiladores.jhonatan.jlanguage.jlanguage.ExpressaoRelacional
import br.compiladores.jhonatan.jlanguage.jlanguage.TermoComparacaoRelacional
import br.compiladores.jhonatan.jlanguage.jlanguage.TermoSubExpressaoRelacional

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JlanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for(p: resource.allContents.toIterable.filter(Programa)){
			fsa.generateFile("Programa.java", p.compilePrograma)
		}
	}

	def compilePrograma(Programa p) '''
		public class Programa{
			«FOR d:p.declaracoes»
			static «getTipo(d)» «d.name»;
			«ENDFOR»

			public static void main(String args[]){
				«FOR c : p.comandos»
					«c.compileComando»
				«ENDFOR»
			}
		}
	'''

	def getTipo(Declaracao d){
		if(d.tipo == "REAL") return "double";
		if(d.tipo == "TEXTO") return "string";
		if(d.tipo == "BOOLEANO") return "boolean";
		return "int";
	}

	def dispatch compileComando(ComandoAtibuicao c)'''
		«c.variavel.name» = «c.exp.compileExpressao»;
	'''

	def dispatch compileComando(ComandoEntrada c)'''
		«IF c.variavel.tipo == "INTEIRO"»
			«c.variavel.name» = Integer.parseInt(System.console().readLine());
		«ELSEIF c.variavel.tipo == "REAL"»
			«c.variavel.name» = Double.parseDouble(System.console().readLine());
		«ELSEIF c.variavel.tipo == "TEXTO"»
			«c.variavel.name» = System.console().readLine();
		«ELSEIF c.variavel.tipo == "BOOLEANO"»
			«c.variavel.name» = Boolean.parseBoolean(System.console().readLine());
		«ENDIF»
	'''

	def dispatch compileComando(ComandoSaida c)'''
		System.out.println(«c.variavel.name»);
	'''

	def dispatch compileComando(ComandoCondicao c)'''
		if(«c.exp.compileExpressaoRelacional») «c.cmd1.compileComando»
		«IF c.cmd2 !== null»else «c.cmd2.compileComando»«ENDIF»
	'''

	def dispatch compileComando(ComandoRepeticao c)'''
		while(«c.exp.compileExpressaoRelacional») «c.cmd.compileComando»
	'''

	def dispatch compileComando(ComandoSubAlgoritmo cs)'''
		{
			«FOR c:cs.comandos»
				«c.compileComando»
			«ENDFOR»
		}
	'''

	def compileExpressao(ExpressaoAritmetica e){
		val ret = new StringConcatenation

		ret.append(e.termo1.compileTermo)
		e.outrosTermos.forEach[ot | 
			ret.append(" "+ot.operador+" "+ot.termo.compileTermo)
		]

		return ret
	}

	def compileTermo(TermoAritmetico t){
		val ret = new StringConcatenation

		ret.append(t.fator1.compileFator)
		t.outrosFatores.forEach[of | 
			ret.append(" "+of.operador+" "+of.fator.compileFator)
		]

		return ret
	}

	def dispatch compileFator(FatorNumero fn)'''«fn.numero»'''
	def dispatch compileFator(FatorVariavel fv)'''«fv.variavel.name»'''
	def dispatch compileFator(FatorSubExpressao fse)'''«fse.expressao.compileExpressao»'''

	def compileExpressaoRelacional(ExpressaoRelacional e){
		val ret = new StringConcatenation

		ret.append(e.termo1.compileTermoRelacional)
		e.outrosTermos.forEach[ot | 
			ret.append(" "+ot.operador.compileOperadorBooleno+" "+ ot.termo.compileTermoRelacional)
		]

		return ret
	}


	def compileOperadorBooleno(String s){
		if(s == "E") return "&&"
		else return "||"
	}

	def dispatch compileTermoRelacional(TermoComparacaoRelacional tcr){
		return tcr.expr1.compileExpressao + " " + tcr.opRel.compileOperadorRelacional + " " + tcr.expr2.compileExpressao
	}

	def dispatch compileTermoRelacional(TermoSubExpressaoRelacional tser)'''(«tser.expRel»)'''

	def compileOperadorRelacional(String s){
		if(s == "<") return "<"
		else if(s == "<=") return "<="
		else if(s == ">") return ">"
		else if(s == ">=") return ">="
		else if(s == "<>") return "!=" 
		else if(s == "=") return "=="
	}
}

```

Após toda essa análise cliando com o botão direito no projeto chamado br.compiladores.jhonatan.jlanguage, e clique em Run as, Eclipse Aplication, porém a primeira vez em que o código for ser executado rode as configurações do das EclipseAplication e configure para o JavaSE-11.

## 📓 Code

Após gerar a EclipseAplication, é necessário criar um projeto Java e criar um arquivo programa.jlang e escreva seu código, se tudo ocorrer como o planejado a EclipseAplication é capaz de reconhecer o extensão .jlang, a própria eclipse aplication é capaz de gerar a pasta scr-gen e o arquivo Programa.java, abaixo segue um exemplo que apresenta todos os comandos que a linguagem é capaz de realizar:

```
:VARIAVEIS
argumento:INTEIRO
fatorial:INTEIRO

:CODIGO
LEIA argumento
ATRIBUIR argumento A fatorial
SE argumento = 0 ENTAO ATRIBUIR 1 A fatorial
ENQUANTO argumento > 1
   INICIO
      ATRIBUIR fatorial * (argumento - 1) A fatorial
      ATRIBUIR argumento - 1 A argumento
   FIM
PRINT fatorial
```

Para testar o seu códgo java é necessário atravéz do terminal acessando a pasta e execute os seguintes comandos:

Caso o seu código apresente algum erro o seguinte comando já é capaz de apresentar os erros no terminal:

```
javac Programa.java
```

Logo após isso rode o seguinte comando:

```
java -cp . Programa
```

Pronto tudo ocorreu como o planejado seu código está funcionando! Fique a vontade para experimentar e codar!

## 📌 Version

O programa está em sua primeira versão completa, a Versão 1.0.

## ✒️ Creator

* **Developer** - [Jhonatan Silvério de Oliveira](https://github.com/Jh0wjso)

---



## 🔔 Notas

O projeto foi desenvolvido a partir do curso de compiladores da UFSCar, link do curso, [Clique Aqui](https://www.youtube.com/playlist?list=PLaPmgS59eMSEKNRIBxuBK4mJr-8pFP3lW).
